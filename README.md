# 毕业设计——基于数字喷泉码和UDP协议的视频传输Demo

一年后看本科毕设写的代码，怎么看都非常不舒服！忍不住要改一下。

## 一、改Makefile

曾经Makefile写的不熟练，先把这块改了。小项目用Makefile组织还是挺简单的，所有文件不分层次地堆在一个目录下，写清楚编译依赖关系，写清楚编译和链接命令。

1. 首先，在写程序的时候，include头文件的时候要洁癖，没有用到的头文件就不要include进去。

2. 定义编译参数、链接参数等变量，这些变量的名字和含义可以参考一些开源项目的`./configure --help`。
```
CC          C compiler command
CFLAGS      C compiler flags
LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
nonstandard directory <lib dir>
LIBS        libraries to pass to the linker, e.g. -l<library>
CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if
you have headers in a nonstandard directory <include dir>
CPP         C preprocessor
LT_SYS_LIBRARY_PATH
User-defined run-time library search path.
```

3. 写一条编译规则，所有的.o文件都由同样的编译命令生成，只是依赖的.cpp文件不一样。
```
%.o: %cpp
	$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
```

4. 依次编写所有可执行文件的链接规则。这里要一条一条的手写，因为不像.o与.cpp文件那样一一对应，一个可执行文件依赖哪些目标文件需要具体分析。

5. 编写clean伪目标。

## 二、UDPServer和UDPClient基类的设计

当年，怎么脑抽了，基类里面混入了UDPEncodedServer、UDPEncodedClient里面才应该有的Encoder、Serializer，统统挪到对应的子类里面，并且修改include关系。

## 三、改变量名

当初的有一些变量在定义的时候太节省笔墨，现在自己的程序都有点看不懂了。

## 四、强化对stdint中明确size的整数类型的使用

当初，只在序列化接序列化的时候使用了stdint中的类型，使用的范围不够广泛，而且用了许多隐式/强制类型转换。现在认为，应该广泛使用stdint中的类型，局部才能考虑使用普通的不指明size的整数类型。

---------------------------------------------------------------------------------------

![image](https://github.com/28hua/graduation-project/raw/master/compare.png)

左图：没有经过编码；右图：经过LT码编码。

这篇README是继一篇发表在我的微信公众号上的文章写的，那篇文章介绍了喷泉码的背景，喷泉码的一个分支Raptor码被写入3GPP，Raptor码的一个实现方法RaptorQ也被高通公司写入RFC6330。

我的毕设实现的是最原始的喷泉码LT码，把树梅派摄像头采集的视频数据经过LT码编码后再发送。研究的结果嘛，呵呵，喷泉码这么用是不合适的。首先，主流的视频都是经过H.264压缩的，这种压缩方法的优势是压缩率高，缺点是帧之间的相关性强，关键帧的错误导致后续一连串的马赛克。喷泉码，尤其LT码的译码存在一定的译码失败概率，根据实现质量的高低这个概率很可能比信道的丢包率还要高。第二，喷泉码要求发送的数据包比原始的数据包稍微多一些，采用这种方案并不比采用TCP协议的重传产生的开销小。徒手实现LT码的编译码费了很大劲儿，编译码又带来时延，真不见得比用TCP协议实现得干净利索。第三，出于译码的需要，编码包需要携带它与原始包的邻接关系，由于视频是实时的，编码包需要携带一个ID标识它是用来译第几块视频的。这两点又带来了开销。第四，是UDP协议的问题。UDP不带反馈，它不像TCP协议或者管道那样带有同步的功能，发端不会因为收端忙得处理不过来就等它一下，白花花的编码包说丢就丢。我用的笨方法是一边两端都加上阻塞队列和专门的编译码线程，一边让发端发完一个包就usleep(100)微秒。毕设也给了我启示，如果有一个网络应用你想要用UDP做，那么十有八九你错了。

我的上一篇文章讲到这个项目最初是用C语言写的，用C语言的问题是这是一门面向过程的语言，写程序的过程中关注点一直是数组、指针、内存管理，造成进度一直比较慢，模块间耦合严重，难以调整编码器的参数，所以我用C++重写了。当时我预计需要设计度分布、编码器、补零数据包、编码包四个类，并且犹豫编解码算法是放到编码器的编解码函数里还是放到编码包、补零数据包的构造函数里。现在C++版本定型，就喷泉码模块而言，我设计了四个类：编码器、补零数据包、编码包、序列化器。对于度分布，那其实是一个离散型随机变量的累积分步，它是纯数据，用一个节点元素为pair的vector表示足以。编解码算法最后放到了编码器的编译码函数里，我觉得概念上这样更合理，而且算法需要获取编码器的配置信息。编码算法需要一个随机数和一个随机序列的发生器，问题抽象出来是：(1)如何产生服从某一分布的随机数，(2)如何从n个数中随机且均匀地选出m个数。这两个问题网上有很多答案，概率论的基础。

方才提到阻塞队列和专门的译码线程。毕设的仓库里有一个阻塞队列的简单实现——BlockQueue.h。原理其实非常简单，使用了最基础的同步原语互斥量和条件变量：生产者线程push(element)时锁住队列，push完成后通知消费者线程，然后解锁；消费者线程pop()element时锁住队列，等待push通知队列非空，然后pop，完成后通知生产者队列不满，解锁。阻塞队列就像shell中的管道，网络协议里的TCP，是居家旅行杀人越货的必备的小东东。

这套小程序原本想要放在无人机上试一下，但是昨天上午起飞前无人机侧翻，一个螺旋浆扎进了草里，电机烧了，怕是飞不成了。
